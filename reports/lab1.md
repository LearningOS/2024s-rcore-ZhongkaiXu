# 实现的功能

在每个TCB中加上程序开始运行时间以及系统调用次数，在切换app的时候，判断开始运行时间是否为0，为0则改为当前时间。在系统调用分发之前，根据syscall id增加TCB里面的系统调用次数。

# 问答题

1. 三个程序出错的原因分别是：

- 访问了0地址
- 使用了sret指令，这个指令应该是S返回U的
- 使用的csrr指令，专属于S态
- SBI版本：[rustsbi] RustSBI version 0.3.0-alpha.2, adapting to RISC-V SBI v1.0.0

2. 第二题
   1. a0是在alltrap传入的sp，内核栈指针。restore用于恢复现场，某个程序陷入S态处理中断结束需要恢复到程序运行时的寄存器状态，另一个场景的两个任务切换的时候，恢复即将运行的程序的上下文。
   2. restore的作用是恢复现场，用的数据是之前alltrap的时候保存下来的，这几个寄存器就是alltrap保存下来的，sstatus的SPP表示进入S态之前是U态，用于sret时恢复的特权级，sepc是进入S态之前的地址，返回到原执行状态，将原来保存下来的用户栈地址放入sscratch，后续和sp切换，保证栈的正确。
   3. x2和x4在alltrap阶段没有保存，暂时没有用到，不用保存。
   4. 在alltrap之前，sscratch的值是内核栈地址，sp是用户栈地址，在restore的末尾需要恢复现场，这里是恢复成alltrap之前的状态。
   5. sret指令。
   6. 这是alltrap中的指令，sscratch的值是内核栈地址，sp是用户栈地址，现在在内核中处理中断，自然要换到内核栈。
   7. ecall指令。

# 荣誉准则

我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
